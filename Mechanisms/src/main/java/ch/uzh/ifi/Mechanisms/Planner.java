package ch.uzh.ifi.Mechanisms;

import ch.uzh.ifi.MechanismDesignPrimitives.Type;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public abstract class Planner 
{

	/*
	 * A superclass constructor only allocates a list for saved states.
	 */
	public Planner()
	{
		_savedStates = new LinkedList<StateMemento>();
		_nTuples = new LinkedList<List<Integer> >();
		_sellersInPlans = new LinkedList<List<Integer> >();
		_buyersInPlans  = new LinkedList<Integer>();
		
		Random generator = new Random();
		generator.setSeed( System.nanoTime() );
		_errorScenarioSeed = generator.nextInt(123456);
	}
	
	/*
	 * The method resets the current planner with a new set of agents and their types. The method generates a set of plans for
	 * numberOfBuyers buyers and numberOfSellers sellers independently of the number of agents actually participating in the
	 * market (i.e., of the cardinality of the submitted set of types, |types|). If an agent with a particular ID is not 
	 * present in 'types', the plan will be discarded at the ::generatePlans() stage.
	 * @param types - types submitted by agents.
	 */
	public abstract void reset(List<Type> types);
	
	/*
	 * The method triggers plan generation.
	 * @return a list of plans generated by the planner.
	 */
	public abstract List<Type> generatePlans();
	
	/*
	 * The method injects an error into the given plan.
	 * @param planIdx - an index of a plan in which an error should be injected.
	 * @return true if an error was injected and false otherwise.
	 */
	public abstract boolean injectError(int planIdx);
	
	/*
	 * The method withdraws the error which was previously injected.
	 */
	public abstract void withdrawError();
	
	/*
	 * 
	 */
	public abstract int getInjectedSeller();

	
	/*
	 * The method returns a set of all generated plans.
	 * @return a set of plans generated by the planner.
	 */
	public List<Type> getPlans()
	{
		return _plans;
	}
	
	/*
	 * The method returns types of agents submitted by agents
	 * @return a list of submitted types
	 */
	public List<Type> getTypes()
	{
		return _types;
	}
	
	/*
	 * The method allows an error to be injected into estimation of the number of tuples.
	 */
	public void makeInjectable()
	{
		isInjectable = true;
	}
	
	/*
	 * The method discards the possibility to inject an error into the number of tuples.
	 */
	public void makeNonInjectable()
	{
		isInjectable = false;
	}
	
	/*
	 * The method saves all required data in a memento object. Only one state can be saved.
	 * @return a memento state
	 */
	public StateMemento saveToMemento()
	{
		if( _savedStates.size() > 0 )											//Already saved
		{
			return _savedStates.get(0);
		}
		else
		{
			StateMemento memento = new StateMemento(_nTuples, _sellersInPlans, _buyersInPlans);
			_savedStates.add(memento);
			return memento;
		}
	}
	
	/*
	 * The method restores the state of the planner from the list of saved states.
	 * @param state - the state to be used for restoring.
	 */
	public void restoreFromMemento( StateMemento state)
	{	
		state.getSavedState(_nTuples, _sellersInPlans, _buyersInPlans);
	}
	
	/*
	 * The method returns the state corresponding to a given index.
	 * @param idx - an index of the saved state to be returned.
	 * @throws an exception if the state index is larger than 2 
	 */
	public StateMemento getStateMemento(int idx)
	{
		if( idx >= 2)  throw new RuntimeException("Wrong index: " + idx);
		return _savedStates.get(idx);
	}

	/*
	 * The method returns the current state of the planner which can be used for restoring other planners.
	 * @return current state of the planner in a Memento object
	 */
	public StateMemento getCurrentState()
	{
		return new StateMemento(_nTuples, _sellersInPlans, _buyersInPlans);
	}
	
	/*
	 * The method specifies the maximum number of plans which can be generated
	 * @param numberOfPlans - the max number of plans
	 */
	public void setNumberOfPlans(int numberOfPlans)
	{
		_numberOfPlans = numberOfPlans;
	}
	
	/*
	 * The method sets up the minimum number of sellers per plan.
	 * @param numberOfSellers - the number of sellers per plan
	 */
	public void setMinSellersPerPlan(int numberOfSellers)
	{
		_minSellersPerPlan = numberOfSellers;
	}
	
	/*
	 * The method sets up the maximum number of sellers per plan
	 * @param numberOfSellers - the max number of sellers per plan
	 */
	public void setMaxSellersPerPlan(int numberOfSellers)
	{
		_maxSellersPerPlan = numberOfSellers;
	}
	
	public void setNumberOfBuyers(int numberOfBuyers)
	{
		_numberOfBuyers = numberOfBuyers;
	}
	
	public void setNumberOfSellers(int numberOfSellers)
	{
		_numberOfSellers = numberOfSellers;
	}
	
	/*
	 * The method returns the maximum number of plans which can be generated.
	 * @return numberOfPlans - the max number of plans
	 */
	public int getNumberOfPlans()
	{
		return _numberOfPlans;
	}
	
	/*
	 * The method returns the minimum number of sellers per plan.
	 * @return the number of sellers per plan
	 */
	public int getMinSellersPerPlan()
	{
		return _minSellersPerPlan;
	}
	
	/*
	 * The method returns the maximum number of sellers per plan
	 * @return the max number of sellers per plan
	 */
	public int getMaxSellersPerPlan()
	{
		return _maxSellersPerPlan;
	}
	
	/*
	 * The class implements a state of the planner to be saved (works according to the Memento Design Pattern)
	 */
	public static class StateMemento
	{
		/*
		 * Constructor performs a deep copy of data.
		 * @param nTuplesEst - a list with numbers of tuples provided by different sellers per plan (the one which should be saved)
		 * @param sellersInPlans - a list of sellers per plan which should be saved
		 */
		public StateMemento(List<List<Integer> > nTuplesEst, List<List<Integer> > sellersInPlans, List<Integer> buyersInPlans)
		{
			_savedTuplesEst =  new LinkedList<List<Integer> >();
			_savedSellersInPlans =  new LinkedList<List<Integer> >();
			_savedBuyersInPlans =  new LinkedList<Integer >();
			_savedTuplesEst = deepCopy(_savedTuplesEst, nTuplesEst);
			_savedSellersInPlans = deepCopy(_savedSellersInPlans, sellersInPlans);
			_savedBuyersInPlans = deepLstCopy(_savedBuyersInPlans, buyersInPlans);
		}
		
		/*
		 * Restoring the data.
		 * @param nTuplesEst - a reference to a list of numbers of tuples per plan
		 * @param sellersInPlans - a reference to a list with numbers of sellers in plans
		 */
		public void getSavedState(List<List<Integer> > nTuplesEst, List<List<Integer> > sellersInPlans, List<Integer> buyersInPlans)
		{
			nTuplesEst.clear();
			sellersInPlans.clear();
			buyersInPlans.clear();
			nTuplesEst = deepCopy( nTuplesEst, _savedTuplesEst);
			sellersInPlans = deepCopy( sellersInPlans, _savedSellersInPlans);
			buyersInPlans = deepLstCopy(buyersInPlans, _savedBuyersInPlans);
		}
		
		/*
		 * The method performs a deep copy of lists
		 * @param listToCopy - a destination list
		 * @param listFromCopy - a source list
		 */
		private List<List<Integer> > deepCopy(List<List<Integer> > listToCopy, List<List<Integer> > listFromCopy)
		{
			for(List<Integer> iList : listFromCopy)
			{
				List<Integer> newList = new LinkedList<Integer>();
				for(Integer i : iList)
					newList.add( (int) i );
				listToCopy.add(newList);
			}
			return listToCopy;
		}
		
		/*
		 * The method performs a deep copy of lists
		 * @param listToCopy - a destination list
		 * @param listFromCopy - a source list
		 */
		private List<Integer> deepLstCopy(List<Integer> listToCopy, List<Integer> listFromCopy)
		{
			for(Integer i : listFromCopy)
				listToCopy.add(i);
			
			return listToCopy;
		}
		
		private List<List<Integer> > _savedTuplesEst;					//The three fields contain all required data to save/restore ...
		private List<List<Integer> > _savedSellersInPlans;				//... the state of the planner.
		private List<Integer>		 _savedBuyersInPlans;
	}
	
	/*
	 * A Database operation executed over a and b numbers of tuples (e.g., JOIN, AGGREGATE etc.)
	 */
	public abstract int dbOperation(int a, int b);
	
	protected boolean isInjectable;										//A flag indicating if an error can be injected into plans
	protected List<StateMemento>   _savedStates;						//A list of saved states of the planner
	protected List<List<Integer> > _nTuples;							//The list contains lists of estimated numbers of triples per plan
	protected List< Integer > _buyersInPlans;							//The list contains numbers of sellers involved in each plan 
	protected List<List<Integer> > _sellersInPlans;						//The list contains lists of sellers involved in every plan
	protected List<Type> _types;										//The list of types reported to the planner
	
	protected long _errorScenarioSeed;									//A random seed for the generator

	protected int _numberOfBuyers;										//The number of buyers
	protected int _numberOfSellers;										//The number of sellers
	protected List<Type> _plans;										//The set of plans generated by the planner
	
	protected int _numberOfPlans;										//The max number of plans can be generated by the planner
	protected int _minSellersPerPlan;									//The min number of sellers per plan
	protected int _maxSellersPerPlan;									//The max number of sellers per plan
	
	protected int _initTuples;
}
