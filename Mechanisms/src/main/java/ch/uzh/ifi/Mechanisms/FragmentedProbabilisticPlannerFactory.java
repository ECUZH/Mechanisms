package ch.uzh.ifi.Mechanisms;

import ch.uzh.ifi.MechanismDesignPrimitives.Type;

import java.util.List;

public class FragmentedProbabilisticPlannerFactory implements IPlannerFactory
{

	/*
	 * Constructor.
	 */
	public FragmentedProbabilisticPlannerFactory(int numberOfBuyers, int numberOfSellers, List<Type> types, boolean isInjectable, int numberOfPlans, int minSellersPerFragment, int maxSellersPerFragment)
	{
		_numberOfBuyers = numberOfBuyers;
		_numberOfSellers = numberOfSellers;
		_types = types;
		_isInjectable = isInjectable;
		_numberOfPlans = numberOfPlans;
		_minSellersPerFragment = minSellersPerFragment;
		_maxSellersPerFragment = maxSellersPerFragment;
	}
	
	@Override
	public Planner producePlanner() 
	{
		
		FragmentedProbabilisticPlanner planner = new FragmentedProbabilisticPlanner(_numberOfBuyers, _numberOfSellers, _types, System.nanoTime());
		planner.setNumberOfPlans(_numberOfPlans);
		planner.setMinSellersPerFragment(_minSellersPerFragment);
		planner.setMaxSellersPerFragment(_maxSellersPerFragment);
		
		if( _isInjectable )
			planner.makeInjectable();
		else
			planner.makeNonInjectable();
		
		planner.reset(_types);
		planner.generatePlans();
		return planner;
	}

	@Override
	public Planner producePlanner(long seed) 
	{
		FragmentedProbabilisticPlanner planner = new FragmentedProbabilisticPlanner(_numberOfBuyers, _numberOfSellers, _types, seed);
		planner.setNumberOfPlans(_numberOfPlans);
		planner.setMinSellersPerFragment(_minSellersPerFragment);
		planner.setMaxSellersPerFragment(_maxSellersPerFragment);
		
		if( _isInjectable )
			planner.makeInjectable();
		else
			planner.makeNonInjectable();
		
		planner.reset(_types);
		planner.generatePlans();
		return planner;
	}

	private boolean _isInjectable;									//A flag indicating if an error can be injected into plans
	private List<Type> _types;										//The list of types reported to the planner	

	private int _numberOfBuyers;									//The number of buyers
	private int _numberOfSellers;									//The number of sellers
	
	private int _numberOfPlans;										//The max number of plans can be generated by the planner
	private int _minSellersPerFragment;								//The min number of sellers per query fragment
	private int _maxSellersPerFragment;								//The max number of sellers per query fragment
}
